
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The mbar module : pymbar.mbar &mdash; pymbar 2.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pymbar 2.0.0 documentation" href="index.html" />
    <link rel="next" title="The testsystems Module : pymbar.testsystems" href="testsystems.html" />
    <link rel="prev" title="Getting started" href="getting_started.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="testsystems.html" title="The testsystems Module : pymbar.testsystems"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="getting_started.html" title="Getting started"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">pymbar 2.0.0 documentation</a> |</li>
<a href="getting_started.html">Getting Started</a> |
<a href="https://github.com/choderalab/pymbar/issues">Bugs</a> |
<a href="examples/index.html">Examples</a> |
<a href="mdconvert.html"><span class="pre">mdconvert</span></a>
 

      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-mbar-module-pymbar-mbar">
<h1>The mbar module : <a class="reference internal" href="#module-pymbar.mbar" title="pymbar.mbar"><tt class="xref py py-class docutils literal"><span class="pre">pymbar.mbar</span></tt></a><a class="headerlink" href="#the-mbar-module-pymbar-mbar" title="Permalink to this headline">¶</a></h1>
<p>The mbar module contains the MBAR class, the key object in pymbar.</p>
<span class="target" id="module-pymbar.mbar"></span><p>A module implementing the multistate Bennett acceptance ratio (MBAR) method for the analysis
of equilibrium samples from multiple arbitrary thermodynamic states in computing equilibrium
expectations, free energy differences, potentials of mean force, and entropy and enthalpy contributions.</p>
<p>Please reference the following if you use this code in your research:</p>
<p>[1] Shirts MR and Chodera JD. Statistically optimal analysis of samples from multiple equilibrium states.
J. Chem. Phys. 129:124105, 2008.  <a class="reference external" href="http://dx.doi.org/10.1063/1.2978177">http://dx.doi.org/10.1063/1.2978177</a></p>
<p>This module contains implementations of</p>
<ul class="simple">
<li>MBAR - multistate Bennett acceptance ratio estimator</li>
</ul>
<dl class="class">
<dt id="pymbar.mbar.MBAR">
<em class="property">class </em><tt class="descclassname">pymbar.mbar.</tt><tt class="descname">MBAR</tt><big>(</big><em>u_kln</em>, <em>N_k</em>, <em>maximum_iterations=10000</em>, <em>relative_tolerance=1e-07</em>, <em>verbose=False</em>, <em>initial_f_k=None</em>, <em>method='adaptive'</em>, <em>use_optimized=None</em>, <em>newton_first_gamma=0.1</em>, <em>newton_self_consistent=2</em>, <em>maxrange=100000.0</em>, <em>initialize='zeros'</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Multistate Bennett acceptance ratio method (MBAR) for the analysis of multiple equilibrium samples.</p>
<p class="rubric">Notes</p>
<p>Note that this method assumes the data are uncorrelated.
Correlated data must be subsampled to extract uncorrelated (effectively independent) samples (see example below).</p>
<p class="rubric">References</p>
<p>[1] Shirts MR and Chodera JD. Statistically optimal analysis of samples from multiple equilibrium states.
J. Chem. Phys. 129:124105, 2008
<a class="reference external" href="http://dx.doi.org/10.1063/1.2978177">http://dx.doi.org/10.1063/1.2978177</a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pymbar.mbar.MBAR.computeEntropyAndEnthalpy" title="pymbar.mbar.MBAR.computeEntropyAndEnthalpy"><tt class="xref py py-obj docutils literal"><span class="pre">computeEntropyAndEnthalpy</span></tt></a>([...])</td>
<td>Compute the decomposition of the free energy difference between states 1 and N into reduced free energy differences, reduced potential (enthalpy) differences, and reduced entropy (S/k) differences.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pymbar.mbar.MBAR.computeExpectations" title="pymbar.mbar.MBAR.computeExpectations"><tt class="xref py py-obj docutils literal"><span class="pre">computeExpectations</span></tt></a>(A_kn[,&nbsp;output,&nbsp;...])</td>
<td>Compute the expectation of an observable of phase space function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pymbar.mbar.MBAR.computeMultipleExpectations" title="pymbar.mbar.MBAR.computeMultipleExpectations"><tt class="xref py py-obj docutils literal"><span class="pre">computeMultipleExpectations</span></tt></a>(A_ikn,&nbsp;u_kn[,&nbsp;...])</td>
<td>Compute the expectations of multiple observables of phase space functions [A_0(x),A_1(x),...,A_n(x)]</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pymbar.mbar.MBAR.computeOverlap" title="pymbar.mbar.MBAR.computeOverlap"><tt class="xref py py-obj docutils literal"><span class="pre">computeOverlap</span></tt></a>([output])</td>
<td>Compute estimate of overlap matrix between the states.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pymbar.mbar.MBAR.computePMF" title="pymbar.mbar.MBAR.computePMF"><tt class="xref py py-obj docutils literal"><span class="pre">computePMF</span></tt></a>(u_kn,&nbsp;bin_kn,&nbsp;nbins[,&nbsp;...])</td>
<td>Compute the free energy of occupying a number of bins.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pymbar.mbar.MBAR.computePMF_states" title="pymbar.mbar.MBAR.computePMF_states"><tt class="xref py py-obj docutils literal"><span class="pre">computePMF_states</span></tt></a>(u_kn,&nbsp;bin_kn,&nbsp;nbins)</td>
<td>Compute the free energy of occupying a number of bins.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pymbar.mbar.MBAR.computePerturbedExpectation" title="pymbar.mbar.MBAR.computePerturbedExpectation"><tt class="xref py py-obj docutils literal"><span class="pre">computePerturbedExpectation</span></tt></a>(u_kn,&nbsp;A_kn[,&nbsp;...])</td>
<td>Compute the expectation of an observable of phase space function A(x) for a single new state.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pymbar.mbar.MBAR.computePerturbedFreeEnergies" title="pymbar.mbar.MBAR.computePerturbedFreeEnergies"><tt class="xref py py-obj docutils literal"><span class="pre">computePerturbedFreeEnergies</span></tt></a>(u_kln[,&nbsp;...])</td>
<td>Compute the free energies for a new set of states.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pymbar.mbar.MBAR.getFreeEnergyDifferences" title="pymbar.mbar.MBAR.getFreeEnergyDifferences"><tt class="xref py py-obj docutils literal"><span class="pre">getFreeEnergyDifferences</span></tt></a>([...])</td>
<td>Get the dimensionless free energy differences and uncertainties among all thermodynamic states.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pymbar.mbar.MBAR.getWeights" title="pymbar.mbar.MBAR.getWeights"><tt class="xref py py-obj docutils literal"><span class="pre">getWeights</span></tt></a></td>
<td>Retrieve the weight matrix W_nk from the MBAR algorithm.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymbar.mbar.MBAR.getWeights">
<tt class="descname">getWeights</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.getWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.getWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the weight matrix W_nk from the MBAR algorithm.</p>
<p>Necessary because they are stored internally as log weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>weights</strong> : np.ndarray, float, shape=(N, K)</p>
<blockquote class="last">
<div><p>NxK matrix of weights in the MBAR covariance and averaging formulas</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.getFreeEnergyDifferences">
<tt class="descname">getFreeEnergyDifferences</tt><big>(</big><em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.getFreeEnergyDifferences"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.getFreeEnergyDifferences" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dimensionless free energy differences and uncertainties among all thermodynamic states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>compute_uncertainty</strong> : bool, optional</p>
<blockquote>
<div><p>If False, the uncertainties will not be computed (default: True)</p>
</div></blockquote>
<p><strong>uncertainty_method</strong> : string, optional</p>
<blockquote>
<div><p>Choice of method used to compute asymptotic covariance method,
or None to use default.  See help for computeAsymptoticCovarianceMatrix()
for more information on various methods. (default: svd)</p>
</div></blockquote>
<p><strong>warning_cutoff</strong> : float, optional</p>
<blockquote>
<div><p>Warn if squared-uncertainty is negative and larger in magnitude
than this number (default: 1.0e-10)</p>
</div></blockquote>
<p><strong>return_theta</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to return the theta matrix.  Can be useful for complicated differences.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>Deltaf_ij :L np.ndarray, float, shape=(K, K)</strong> :</p>
<blockquote>
<div><p>Deltaf_ij[i,j] is the estimated free energy difference</p>
</div></blockquote>
<p><strong>dDeltaf_ij :L np.ndarray, float, shape=(K, K)</strong> :</p>
<blockquote class="last">
<div><p>dDeltaf_ij[i,j] is the estimated statistical uncertainty 
(one standard deviation) in Deltaf_ij[i,j]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Computation of the covariance matrix may take some time for large K.</p>
<p>The reported statistical uncertainty should, in the asymptotic limit, reflect one standard deviation for the normal distribution of the estimate.
The true free energy difference should fall within the interval [-df, +df] centered on the estimate 68% of the time, and within
the interval [-2 df, +2 df] centered on the estimate 95% of the time.
This will break down in cases where the number of samples is not large enough to reach the asymptotic normal limit.</p>
<p>See Section III of Reference [1].</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">oldtestsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldtestsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsSample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">Deltaf_ij</span><span class="p">,</span> <span class="n">dDeltaf_ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">getFreeEnergyDifferences</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computeExpectations">
<tt class="descname">computeExpectations</tt><big>(</big><em>A_kn</em>, <em>output='averages'</em>, <em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.computeExpectations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.computeExpectations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the expectation of an observable of phase space function.</p>
<p>Compute the expectation of an observable of phase space function 
A(x) at all K states, including states for which no samples 
were drawn. A may be a function of the state k.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>A</strong> : np.ndarray, float</p>
<blockquote>
<div><p>Two possibilities, depending on if the observable is a function of the state or not.
either: not dependent on the state
A_kn (KxN_max numpy float64 array) - A_kn[k,n] = A(x_kn)
or: dependent on state
A_kn (KxKxN_max numpy float64 array) - A_kn[k,l,n] = A(x_kn)
where the 2nd dimension is the observable as a function of the state</p>
</div></blockquote>
<p><strong>output</strong> : string, optional</p>
<blockquote>
<div><p>Either output averages, and uncertainties, or output a matrix of differences, with uncertainties.</p>
</div></blockquote>
<p><strong>compute_uncertainty</strong> : bool, optional</p>
<blockquote>
<div><p>If False, the uncertainties will not be computed (default: True)</p>
</div></blockquote>
<p><strong>uncertainty_method</strong> : string, optional</p>
<blockquote>
<div><p>Choice of method used to compute asymptotic covariance method, 
or None to use default See help for computeAsymptoticCovarianceMatrix()</p>
<blockquote>
<div><p>for more information on various methods. (default: None)</p>
</div></blockquote>
</div></blockquote>
<p><strong>warning_cutoff</strong> : float, optional</p>
<blockquote>
<div><p>Warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)</p>
</div></blockquote>
<p><strong>return_theta</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to return the theta matrix.  Can be useful for complicated differences.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>A</strong> : np.ndarray, float</p>
<blockquote>
<div><p>if output is &#8216;averages&#8217;
A_i  (K numpy float64 array) -  A_i[k] is the estimate for the expectation of A(x) for state k.
if output is &#8216;differences&#8217;
A_ij (K numpy float64 array) -  A_ij[i,j] is the difference in the estimates for the expectation of A(x).</p>
</div></blockquote>
<p><strong>dA</strong> : np.ndarray, float</p>
<blockquote class="last">
<div><p>dA_i  (K numpy float64 array) - dA_i[k] is uncertainty estimate (one standard deviation) for A_k[k]
or
dA_ij (K numpy float64 array) - dA_ij[i,j] is uncertainty estimate (one standard deviation) for the difference in A beteen i and j</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The reported statistical uncertainty should, in the asymptotic limit, reflect one standard deviation for the normal distribution of the estimate.
The true expectation should fall within the interval [-dA, +dA] centered on the estimate 68% of the time, and within
the interval [-2 dA, +2 dA] centered on the estimate 95% of the time.
This will break down in cases where the number of samples is not large enough to reach the asymptotic normal limit.
This &#8216;breakdown&#8217; can be exacerbated by the computation of observables like indicator functions for histograms that are sparsely populated.</p>
<p class="rubric">References</p>
<p>See Section IV of [1].</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">oldtestsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldtestsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsSample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_kn</span> <span class="o">=</span> <span class="n">x_kn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A_ij</span><span class="p">,</span> <span class="n">dA_ij</span><span class="p">)</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeExpectations</span><span class="p">(</span><span class="n">A_kn</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_kn</span> <span class="o">=</span> <span class="n">u_kln</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A_ij</span><span class="p">,</span> <span class="n">dA_ij</span><span class="p">)</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeExpectations</span><span class="p">(</span><span class="n">A_kn</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&#39;differences&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computeMultipleExpectations">
<tt class="descname">computeMultipleExpectations</tt><big>(</big><em>A_ikn</em>, <em>u_kn</em>, <em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.computeMultipleExpectations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.computeMultipleExpectations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the expectations of multiple observables of phase space functions [A_0(x),A_1(x),...,A_n(x)]
at single specified state, along with the covariances of their estimates.  The state is specified by</p>
<blockquote>
<div>the choice of u_kn, which is the energy of the kxn samples evaluated at the chosen state.  Note that
these variables A should NOT be functions of the state!</div></blockquote>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS</dt>
<dd>A_ikn (IxKxN_max numpy float64 array) - A_ikn[i,k,n] = A_i(x_kn), the value of phase observable i for configuration n at state k
u_kn (KxN_max numpy float64 array) - u_kn[k,n] is the reduced potential of configuration n gathered from state k, at the state of interest</dd>
<dt>OPTIONAL ARUMENTS</dt>
<dd><dl class="first docutils">
<dt>uncertainty_method (string) - choice of method used to compute asymptotic covariance method, or None to use default</dt>
<dd>See help for computeAsymptoticCovarianceMatrix() for more information on various methods. (default: None)</dd>
<dt>uncertainty_method (string) - choice of method used to compute asymptotic covariance method, or None to use default</dt>
<dd>See help for computeAsymptoticCovarianceMatrix() for more information on various methods. (default: svd)</dd>
</dl>
<p class="last">warning_cutoff (float) - warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)
return_theta (boolean) - whether or not to return the theta matrix.  Can be useful for complicated differences.</p>
</dd>
<dt>RETURN VALUES</dt>
<dd>A_i (I numpy float64 array) - A_i[i] is the estimate for the expectation of A_i(x) at the state specified by u_kn
d2A_ij (IxI numpy float64 array) - d2A_ij[i,j] is the COVARIANCE in the estimates of A_i[i] and A_i[j],
not the square root of the covariance</dd>
</dl>
<p>NOTE: Not fully tested.</p>
<p>TESTS</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">oldtestsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldtestsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsSample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_ikn</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_kn</span><span class="p">,</span><span class="n">x_kn</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">x_kn</span><span class="o">**</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_kn</span> <span class="o">=</span> <span class="n">u_kln</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">A_i</span><span class="p">,</span> <span class="n">d2A_ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeMultipleExpectations</span><span class="p">(</span><span class="n">A_ikn</span><span class="p">,</span> <span class="n">u_kn</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computeOverlap">
<tt class="descname">computeOverlap</tt><big>(</big><em>output='scalar'</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.computeOverlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.computeOverlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute estimate of overlap matrix between the states.</p>
<p>RETURNS</p>
<blockquote>
<div><dl class="docutils">
<dt>O (numpy.array of numpy.float64 of dimension [K,K]) - estimated state overlap matrix</dt>
<dd>O[i,j] is an estimate of the probability of observing a sample from state i in state j</dd>
</dl>
</div></blockquote>
<p>OPTIONAL ARGUMENTS</p>
<blockquote>
<div>output (string): One of &#8216;scalar&#8217;, &#8216;matrix&#8217;, &#8216;eigenvalues&#8217;, &#8216;all&#8217;, specifying what measure
of overlap to return</div></blockquote>
<p>NOTES</p>
<dl class="docutils">
<dt>W.T * W pprox int (p_i p_j /sum_k N_k p_k)^2 sum_k N_k p_k dq^N</dt>
<dd>= int (p_i p_j /sum_k N_k p_k) dq^N</dd>
</dl>
<p>Multiplying elementwise by N_i, the elements of row i give the probability
for a sample from state i being observed in state j.</p>
<p>TEST</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">oldtestsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldtestsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsSample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O_ij</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeOverlap</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computePerturbedExpectation">
<tt class="descname">computePerturbedExpectation</tt><big>(</big><em>u_kn</em>, <em>A_kn</em>, <em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.computePerturbedExpectation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.computePerturbedExpectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the expectation of an observable of phase space function A(x) for a single new state.</p>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS</dt>
<dd>u_kn (KxN_max numpy float64 array) - u_kn[k,n] = u(x_kn) - the energy of the new state at all N samples previously sampled.
A_kn (KxN_max numpy float64 array) - A_kn[k,n] = A(x_kn) - the phase space function of the new state at all N samples previously sampled.  If this does NOT depend on state (e.g. position), it&#8217;s simply the value of the observation.  If it DOES depend on the current state, then the observables from the previous states need to be reevaluated at THIS state.</dd>
<dt>OPTIONAL ARUMENTS</dt>
<dd><p class="first">compute_uncertainty (boolean) - if set to False, the uncertainties will not be computed (default: True)
uncertainty_method (string) - choice of method used to compute asymptotic covariance method, or None to use default</p>
<blockquote>
<div>See help for computeAsymptoticCovarianceMatrix() for more information on various methods. (default: None)</div></blockquote>
<p class="last">warning_cutoff (float) - warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)
return_theta (boolean) - whether or not to return the theta matrix.  Can be useful for complicated differences.</p>
</dd>
<dt>RETURN VALUES</dt>
<dd>A (double) - A is the estimate for the expectation of A(x) for the specified state
dA (double) - dA is uncertainty estimate for A</dd>
<dt>REFERENCE</dt>
<dd>See Section IV of [1].</dd>
</dl>
<p># Compute estimators and uncertainty.
#A = sum(W_nk[:,K] * A_n[:]) # Eq. 15 of [1]
#dA = abs(A) * numpy.sqrt(Theta_ij[K,K] + Theta_ij[K+1,K+1] - 2.0 * Theta_ij[K,K+1]) # Eq. 16 of [1]</p>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computePerturbedFreeEnergies">
<tt class="descname">computePerturbedFreeEnergies</tt><big>(</big><em>u_kln</em>, <em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.computePerturbedFreeEnergies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.computePerturbedFreeEnergies" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the free energies for a new set of states.
Here, we desire the free energy differences among a set of new states, as well as the uncertainty estimates in these differences.</p>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS</dt>
<dd><dl class="first last docutils">
<dt>u_kln (KxLxNmax float array) - u_kln[k,l,n] is the reduced potential energy of uncorrelated configuration n sampled from state k, evaluated at new state l.</dt>
<dd>L need not be the same as K.</dd>
</dl>
</dd>
<dt>OPTINAL ARUMENTS</dt>
<dd><p class="first">compute_uncertainty (boolean) - if set to False, the uncertainties will not be computed (default: True)
uncertainty_method (string) - choice of method used to compute asymptotic covariance method, or None to use default</p>
<blockquote>
<div>See help for computeAsymptoticCovarianceMatrix() for more information on various methods. (default: None)</div></blockquote>
<p class="last">warning_cutoff (float) - warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)</p>
</dd>
<dt>RETURN VALUES</dt>
<dd>Deltaf_ij (LxL numpy float64 array) - Deltaf_ij[i,j] = f_j - f_i, the dimensionless free energy difference between new states i and j
dDeltaf_ij (LxL numpy float64 array) - dDeltaf_ij[i,j] is the estimated statistical uncertainty in Deltaf_ij[i,j]</dd>
</dl>
<p>TEST</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">oldtestsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldtestsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsSample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">Deltaf_ij</span><span class="p">,</span> <span class="n">dDeltaf_ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computePerturbedFreeEnergies</span><span class="p">(</span><span class="n">u_kln</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computeEntropyAndEnthalpy">
<tt class="descname">computeEntropyAndEnthalpy</tt><big>(</big><em>uncertainty_method=None</em>, <em>verbose=False</em>, <em>warning_cutoff=1e-10</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.computeEntropyAndEnthalpy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.computeEntropyAndEnthalpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the decomposition of the free energy difference between states 1 and N into reduced free energy differences, reduced potential (enthalpy) differences, and reduced entropy (S/k) differences.</p>
<dl class="docutils">
<dt>OPTINAL ARUMENTS</dt>
<dd><dl class="first docutils">
<dt>uncertainty_method (string) - choice of method used to compute asymptotic covariance method, or None to use default</dt>
<dd>See help for computeAsymptoticCovarianceMatrix() for more information on various methods. (default: None)</dd>
</dl>
<p class="last">warning_cutoff (float) - warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)</p>
</dd>
<dt>RETURN VALUES</dt>
<dd>Delta_f_ij (KxK numpy float matrix) - Delta_f_ij[i,j] is the dimensionless free energy difference f_j - f_i
dDelta_f_ij (KxK numpy float matrix) - uncertainty in Delta_f_ij
Delta_u_ij (KxK numpy float matrix) - Delta_u_ij[i,j] is the reduced potential energy difference u_j - u_i
dDelta_u_ij (KxK numpy float matrix) - uncertainty in Delta_f_ij
Delta_s_ij (KxK numpy float matrix) - Delta_s_ij[i,j] is the reduced entropy difference S/k between states i and j (s_j - s_i)
dDelta_s_ij (KxK numpy float matrix) - uncertainty in Delta_s_ij</dd>
<dt>WARNING</dt>
<dd>This method is EXPERIMENTAL and should be used at your own risk.</dd>
</dl>
<p>TEST</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">oldtestsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldtestsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsSample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">Delta_f_ij</span><span class="p">,</span> <span class="n">dDelta_f_ij</span><span class="p">,</span> <span class="n">Delta_u_ij</span><span class="p">,</span> <span class="n">dDelta_u_ij</span><span class="p">,</span> <span class="n">Delta_s_ij</span><span class="p">,</span> <span class="n">dDelta_s_ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeEntropyAndEnthalpy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computePMF">
<tt class="descname">computePMF</tt><big>(</big><em>u_kn</em>, <em>bin_kn</em>, <em>nbins</em>, <em>uncertainties='from-lowest'</em>, <em>pmf_reference=None</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.computePMF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.computePMF" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the free energy of occupying a number of bins.
This implementation computes the expectation of an indicator-function observable for each bin.</p>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS</dt>
<dd>u_kn[k,n] is the reduced potential energy of snapshot n of state k for which the PMF is to be computed.
bin_kn[k,n] is the bin index of snapshot n of state k.  bin_kn can assume a value in range(0,nbins)
nbins is the number of bins</dd>
<dt>OPTIONAL ARGUMENTS</dt>
<dd><dl class="first last docutils">
<dt>uncertainties (string) - choose method for reporting uncertainties (default: &#8216;from-lowest&#8217;)</dt>
<dd>&#8216;from-lowest&#8217; - the uncertainties in the free energy difference with lowest point on PMF are reported
&#8216;from-reference&#8217; - same as from lowest, but from a user specified point
&#8216;from-normalization&#8217; - the normalization sum_i p_i = 1 is used to determine uncertainties spread out through the PMF
&#8216;all-differences&#8217; - the nbins x nbins matrix df_ij of uncertainties in free energy differences is returned instead of df_i</dd>
</dl>
</dd>
<dt>RETURN VALUES</dt>
<dd>f_i[i], i = 0..nbins - the dimensionless free energy of state i, relative to the state of lowest free energy
df_i[i] is the uncertainty in the difference of f_i with respect to the state of lowest free energy</dd>
<dt>NOTES</dt>
<dd>All bins must have some samples in them from at least one of the states &#8211; this will not work if bin_kn.sum(0) == 0. Empty bins should be removed before calling computePMF().
This method works by computing the free energy of localizing the system to each bin for the given potential by aggregating the log weights for the given potential.
To estimate uncertainties, the NxK weight matrix W_nk is augmented to be Nx(K+nbins) in order to accomodate the normalized weights of states where
the potential is given by u_kn within each bin and infinite potential outside the bin.  The uncertainties with respect to the bin of lowest free energy
are then computed in the standard way.</dd>
<dt>WARNING</dt>
<dd>This method is EXPERIMENTAL and should be used at your own risk.</dd>
</dl>
<p>TEST</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">oldtestsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldtestsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsSample</span><span class="p">(</span><span class="n">N_k</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_kn</span> <span class="o">=</span> <span class="n">u_kln</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xmin</span> <span class="o">=</span> <span class="n">x_kn</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xmax</span> <span class="o">=</span> <span class="n">x_kn</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nbins</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.00001</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bin_kn</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x_kn</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">f_i</span><span class="p">,</span> <span class="n">df_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computePMF</span><span class="p">(</span><span class="n">u_kn</span><span class="p">,</span> <span class="n">bin_kn</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computePMF_states">
<tt class="descname">computePMF_states</tt><big>(</big><em>u_kn</em>, <em>bin_kn</em>, <em>nbins</em><big>)</big><a class="reference internal" href="_modules/pymbar/mbar.html#MBAR.computePMF_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymbar.mbar.MBAR.computePMF_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the free energy of occupying a number of bins.
This implementation defines each bin as a separate thermodynamic state.</p>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS</dt>
<dd>u_kn[k,n] is the reduced potential energy of snapshot n of state k for which the PMF is to be computed.
bin_kn[k,n] is the bin index of snapshot n of state k.  bin_kn can assume a value in range(0,nbins)
nbins is the number of bins</dd>
<dt>OPTIONAL ARGUMENTS</dt>
<dd>fmax is the maximum value of the free energy, used for an empty bin (default: 1000)</dd>
<dt>RETURN VALUES</dt>
<dd>f_i[i], i = 0..nbins - the dimensionless free energy of state i, relative to the state of lowest free energy
d2f_ij[i,j] is the uncertainty in the difference of (f_i - f_j)</dd>
<dt>NOTES</dt>
<dd>All bins must have some samples in them from at least one of the states &#8211; this will not work if bin_kn.sum(0) == 0. Empty bins should be removed before calling computePMF().
This method works by computing the free energy of localizing the system to each bin for the given potential by aggregating the log weights for the given potential.
To estimate uncertainties, the NxK weight matrix W_nk is augmented to be Nx(K+nbins) in order to accomodate the normalized weights of states where
the potential is given by u_kn within each bin and infinite potential outside the bin.  The uncertainties with respect to the bin of lowest free energy
are then computed in the standard way.</dd>
<dt>WARNING</dt>
<dd>This method is EXPERIMENTAL and should be used at your own risk.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<a href="index.html"><img src="_static/pymbar.png" alt="Logo"/></a>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/mbar.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="testsystems.html" title="The testsystems Module : pymbar.testsystems"
             >next</a> |</li>
        <li class="right" >
          <a href="getting_started.html" title="Getting started"
             >previous</a> |</li>
        <li><a href="index.html">pymbar 2.0.0 documentation</a> |</li>
<a href="getting_started.html">Getting Started</a> |
<a href="https://github.com/choderalab/pymbar/issues">Bugs</a> |
<a href="examples/index.html">Examples</a> |
<a href="mdconvert.html"><span class="pre">mdconvert</span></a>
 

      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2013, Robert McGibbon and contributors.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42143125-1', 'rmcgibbo.github.io');
  ga('send', 'pageview');
</script>

  </body>
</html>