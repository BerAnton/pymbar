

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The timeseries module : pymbar.timeseries &mdash; pymbar 2.1.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="pymbar 2.1.0 documentation" href="index.html"/>
        <link rel="next" title="The testsystems Module : pymbar.testsystems" href="testsystems.html"/>
        <link rel="prev" title="The mbar module : pymbar.mbar" href="mbar.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> pymbar</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#installing-pymbar">Installing <tt class="docutils literal"><span class="pre">pymbar</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#running-the-tests">Running the tests</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mbar.html">The mbar module : <tt class="docutils literal"><span class="pre">pymbar.mbar</span></tt></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">The timeseries module : <tt class="docutils literal"><span class="pre">pymbar.timeseries</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="testsystems.html">The testsystems Module : <tt class="docutils literal"><span class="pre">pymbar.testsystems</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utilities : <tt class="docutils literal"><span class="pre">pymbar.utils</span></tt></a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">pymbar</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>The timeseries module : <tt class="docutils literal"><span class="pre">pymbar.timeseries</span></tt></li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/timeseries.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="the-timeseries-module-pymbar-timeseries">
<h1>The timeseries module : <a class="reference internal" href="#module-pymbar.timeseries" title="pymbar.timeseries"><tt class="xref py py-class docutils literal"><span class="pre">pymbar.timeseries</span></tt></a><a class="headerlink" href="#the-timeseries-module-pymbar-timeseries" title="Permalink to this headline">¶</a></h1>
<p>The timeseries module contains tools for dealing with timeseries data.</p>
<span class="target" id="module-pymbar.timeseries"></span><p>A module for extracting uncorrelated samples from correlated timeseries data.</p>
<p>This module provides various tools that allow one to examine the correlation functions and
integrated autocorrelation times in correlated timeseries data, compute statistical inefficiencies,
and automatically extract uncorrelated samples for data analysis.</p>
<p>REFERENCES</p>
<p>[1] Shirts MR and Chodera JD. Statistically optimal analysis of samples from multiple equilibrium states.
J. Chem. Phys. 129:124105, 2008
<a class="reference external" href="http://dx.doi.org/10.1063/1.2978177">http://dx.doi.org/10.1063/1.2978177</a></p>
<p>[2] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted
histogram analysis method for the analysis of simulated and parallel tempering simulations.
JCTC 3(1):26-41, 2007.</p>
<dl class="function">
<dt id="pymbar.timeseries.detectEquilibration">
<tt class="descclassname">pymbar.timeseries.</tt><tt class="descname">detectEquilibration</tt><span class="sig-paren">(</span><em>A_t</em>, <em>fast=True</em>, <em>nskip=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.timeseries.detectEquilibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically detect equilibrated region of a dataset using a heuristic that maximizes number of effectively uncorrelated samples.</p>
<p>ARGUMENTS</p>
<p>A_t (numpy.array) - timeseries</p>
<p>OPTIONAL ARGUMENTS</p>
<p>nskip (int) - number of samples to sparsify data by in order to speed equilibration detection</p>
<p>RETURNS</p>
<p>t (int) - start of equilibrated data
g (float) - statistical inefficiency of equilibrated data
Neff_max (float) - number of uncorrelated samples</p>
<p>TODO</p>
<p>Consider implementing a binary search for Neff_max.</p>
<p>EXAMPLE</p>
<p>Determine start of equilibrated data for a correlated timeseries.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_t</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">correlated_timeseries_example</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span> <span class="c"># generate a test correlated timeseries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">Neff_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectEquilibration</span><span class="p">(</span><span class="n">A_t</span><span class="p">)</span> <span class="c"># compute indices of uncorrelated timeseries</span>
</pre></div>
</div>
<p>Determine start of equilibrated data for a correlated timeseries with a shift.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_t</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">correlated_timeseries_example</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="c"># generate a test correlated timeseries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B_t</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">correlated_timeseries_example</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span> <span class="c"># generate a test correlated timeseries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C_t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">A_t</span><span class="p">,</span> <span class="n">B_t</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">Neff_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectEquilibration</span><span class="p">(</span><span class="n">C_t</span><span class="p">,</span> <span class="n">nskip</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span> <span class="c"># compute indices of uncorrelated timeseries</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pymbar.timeseries.integratedAutocorrelationTime">
<tt class="descclassname">pymbar.timeseries.</tt><tt class="descname">integratedAutocorrelationTime</tt><span class="sig-paren">(</span><em>A_n</em>, <em>B_n=None</em>, <em>fast=False</em>, <em>mintime=3</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.timeseries.integratedAutocorrelationTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the integrated autocorrelation time.</p>
</dd></dl>

<dl class="function">
<dt id="pymbar.timeseries.integratedAutocorrelationTimeMultiple">
<tt class="descclassname">pymbar.timeseries.</tt><tt class="descname">integratedAutocorrelationTimeMultiple</tt><span class="sig-paren">(</span><em>A_kn</em>, <em>fast=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.timeseries.integratedAutocorrelationTimeMultiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the integrated autocorrelation time from multiple timeseries.</p>
</dd></dl>

<dl class="function">
<dt id="pymbar.timeseries.normalizedFluctuationCorrelationFunction">
<tt class="descclassname">pymbar.timeseries.</tt><tt class="descname">normalizedFluctuationCorrelationFunction</tt><span class="sig-paren">(</span><em>A_n</em>, <em>B_n=None</em>, <em>N_max=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.timeseries.normalizedFluctuationCorrelationFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the normalized fluctuation (cross) correlation function of (two) stationary timeseries.</p>
<p>C(t) = (&lt;A(t) B(t)&gt; - &lt;A&gt;&lt;B&gt;) / (&lt;AB&gt; - &lt;A&gt;&lt;B&gt;)</p>
<p>This may be useful in diagnosing odd time-correlations in timeseries data.</p>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS  </dt>
<dd>A_n[n] is nth value of timeseries A.  Length is deduced from vector.
B_n[n] is nth value of timeseries B.  Length is deduced from vector.</dd>
<dt>OPTIONAL ARGUMENTS</dt>
<dd>N_max - if specified, will only compute correlation function out to time lag of N_max</dd>
<dt>RETURNS</dt>
<dd>C_n[n] is the normalized fluctuation auto- or cross-correlation function for timeseries A(t) and B(t).</dd>
<dt>NOTES </dt>
<dd>The same timeseries can be used for both A_n and B_n to get the autocorrelation statistical inefficiency.
This procedure may be slow.
The statistical error in C_n[n] will grow with increasing n.  No effort is made here to estimate the uncertainty.</dd>
<dt>REFERENCES  </dt>
<dd>[1] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted
histogram analysis method for the analysis of simulated and parallel tempering simulations.
JCTC 3(1):26-41, 2007.</dd>
</dl>
<p>EXAMPLES</p>
<p>Estimate normalized fluctuation correlation function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_t</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">correlated_timeseries_example</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C_t</span> <span class="o">=</span> <span class="n">normalizedFluctuationCorrelationFunction</span><span class="p">(</span><span class="n">A_t</span><span class="p">,</span> <span class="n">N_max</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pymbar.timeseries.normalizedFluctuationCorrelationFunctionMultiple">
<tt class="descclassname">pymbar.timeseries.</tt><tt class="descname">normalizedFluctuationCorrelationFunctionMultiple</tt><span class="sig-paren">(</span><em>A_kn</em>, <em>B_kn=None</em>, <em>N_max=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.timeseries.normalizedFluctuationCorrelationFunctionMultiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the normalized fluctuation (cross) correlation function of (two) timeseries from multiple timeseries samples.</p>
<p>C(t) = (&lt;A(t) B(t)&gt; - &lt;A&gt;&lt;B&gt;) / (&lt;AB&gt; - &lt;A&gt;&lt;B&gt;)</p>
<p>This may be useful in diagnosing odd time-correlations in timeseries data.</p>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS  </dt>
<dd>A_kn (Python list of numpy arrays) - A_kn[k] is the kth timeseries, and A_kn[k][n] is nth value of timeseries k.  Length is deduced from arrays.
B_kn (Python list of numpy arrays) - B_kn[k] is the kth timeseries, and B_kn[k][n] is nth value of timeseries k.  B_kn[k] must have same length as A_kn[k]</dd>
<dt>OPTIONAL ARGUMENTS</dt>
<dd>N_max - if specified, will only compute correlation function out to time lag of N_max</dd>
<dt>RETURNS</dt>
<dd>C_n[n] is the normalized fluctuation auto- or cross-correlation function for timeseries A(t) and B(t).</dd>
<dt>NOTES</dt>
<dd>The same timeseries can be used for both A_n and B_n to get the autocorrelation statistical inefficiency.
This procedure may be slow.
The statistical error in C_n[n] will grow with increasing n.  No effort is made here to estimate the uncertainty.</dd>
<dt>REFERENCES  </dt>
<dd>[1] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted
histogram analysis method for the analysis of simulated and parallel tempering simulations.
JCTC 3(1):26-41, 2007.</dd>
</dl>
<p>EXAMPLES</p>
<p>Estimate a portion of the normalized fluctuation autocorrelation function from multiple timeseries of different length.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="c"># exponential relaxation time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_kn</span> <span class="o">=</span> <span class="p">[</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">correlated_timeseries_example</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">N_k</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C_n</span> <span class="o">=</span> <span class="n">normalizedFluctuationCorrelationFunctionMultiple</span><span class="p">(</span><span class="n">A_kn</span><span class="p">,</span> <span class="n">N_max</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pymbar.timeseries.statisticalInefficiency">
<tt class="descclassname">pymbar.timeseries.</tt><tt class="descname">statisticalInefficiency</tt><span class="sig-paren">(</span><em>A_n</em>, <em>B_n=None</em>, <em>fast=False</em>, <em>mintime=3</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.timeseries.statisticalInefficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (cross) statistical inefficiency of (two) timeseries.</p>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS  </dt>
<dd>A_n (numpy array) - A_n[n] is nth value of timeseries A.  Length is deduced from vector.</dd>
<dt>OPTIONAL ARGUMENTS</dt>
<dd><dl class="first last docutils">
<dt>B_n (numpy array) - B_n[n] is nth value of timeseries B.  Length is deduced from vector.</dt>
<dd>If supplied, the cross-correlation of timeseries A and B will be estimated instead of the
autocorrelation of timeseries A.</dd>
<dt>fast (boolean) - if True, will use faster (but less accurate) method to estimate correlation</dt>
<dd>time, described in Ref. [1] (default: False)</dd>
<dt>mintime (int) - minimum amount of correlation function to compute (default: 3)</dt>
<dd>The algorithm terminates after computing the correlation time out to mintime when the
correlation function furst goes negative.  Note that this time may need to be increased
if there is a strong initial negative peak in the correlation function.</dd>
</dl>
</dd>
<dt>RETURNS</dt>
<dd><dl class="first last docutils">
<dt>g is the estimated statistical inefficiency (equal to 1 + 2 tau, where tau is the correlation time).</dt>
<dd>We enforce g &gt;= 1.0.</dd>
</dl>
</dd>
<dt>NOTES </dt>
<dd>The same timeseries can be used for both A_n and B_n to get the autocorrelation statistical inefficiency.
The fast method described in Ref [1] is used to compute g.</dd>
<dt>REFERENCES  </dt>
<dd>[1] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted
histogram analysis method for the analysis of simulated and parallel tempering simulations.
JCTC 3(1):26-41, 2007.</dd>
</dl>
<p>EXAMPLES</p>
<p>Compute statistical inefficiency of timeseries data with known correlation time.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar.testsystems</span> <span class="kn">import</span> <span class="n">correlated_timeseries_example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_n</span> <span class="o">=</span> <span class="n">correlated_timeseries_example</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">statisticalInefficiency</span><span class="p">(</span><span class="n">A_n</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pymbar.timeseries.statisticalInefficiencyMultiple">
<tt class="descclassname">pymbar.timeseries.</tt><tt class="descname">statisticalInefficiencyMultiple</tt><span class="sig-paren">(</span><em>A_kn</em>, <em>fast=False</em>, <em>return_correlation_function=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.timeseries.statisticalInefficiencyMultiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the statistical inefficiency from multiple stationary timeseries (of potentially differing lengths).</p>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS  </dt>
<dd>A_kn (Python list of numpy arrays) - A_kn[k] is the kth timeseries, and A_kn[k][n] is nth value of timeseries k.  Length is deduced from arrays.</dd>
<dt>OPTIONAL ARGUMENTS  </dt>
<dd>fast can be set to True to give a less accurate but very quick estimate (default False)
return_correlation_function - if True, will also return estimates of normalized fluctuation correlation function that were computed (default: False)</dd>
<dt>RETURNS</dt>
<dd>g is the statistical inefficiency (equal to 1 + 2 tau, where tau is the integrated autocorrelation time).
Ct (list of tuples) - Ct[n] = (t, C) with time t and normalized correlation function estimate C is returned as well if return_correlation_function is set to True</dd>
<dt>NOTES </dt>
<dd>The autocorrelation of the timeseries is used to compute the statistical inefficiency.
The normalized fluctuation autocorrelation function is computed by averaging the unnormalized raw correlation functions.
The fast method described in Ref [1] is used to compute g.</dd>
<dt>REFERENCES  </dt>
<dd>[1] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted
histogram analysis method for the analysis of simulated and parallel tempering simulations.
JCTC 3(1):26-41, 2007.</dd>
</dl>
<p>EXAMPLES</p>
<p>Estimate statistical efficiency from multiple timeseries of different lengths.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="c"># exponential relaxation time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_kn</span> <span class="o">=</span> <span class="p">[</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">correlated_timeseries_example</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">N_k</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">statisticalInefficiencyMultiple</span><span class="p">(</span><span class="n">A_kn</span><span class="p">)</span>
</pre></div>
</div>
<p>Also return the values of the normalized fluctuation autocorrelation function that were computed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">Ct</span><span class="p">]</span> <span class="o">=</span> <span class="n">statisticalInefficiencyMultiple</span><span class="p">(</span><span class="n">A_kn</span><span class="p">,</span> <span class="n">return_correlation_function</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pymbar.timeseries.subsampleCorrelatedData">
<tt class="descclassname">pymbar.timeseries.</tt><tt class="descname">subsampleCorrelatedData</tt><span class="sig-paren">(</span><em>A_t</em>, <em>g=None</em>, <em>fast=False</em>, <em>conservative=False</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.timeseries.subsampleCorrelatedData" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the indices of an uncorrelated subsample of the data.</p>
<dl class="docutils">
<dt>REQUIRED ARGUMENTS  </dt>
<dd>A_t (T array) - A_t[t] is the t-th value of timeseries A(t).  Length is deduced from vector.</dd>
<dt>OPTIONAL ARGUMENTS</dt>
<dd><p class="first">g (float) - if provided, the statistical inefficiency g is used to subsample the timeseries &#8211; otherwise it will be computed (default: None)
fast (logical) - fast can be set to True to give a less accurate but very quick estimate (default: False)
conservative (logical) - if set to True, uniformly-spaced indices are chosen with interval ceil(g), where</p>
<blockquote>
<div>g is the statistical inefficiency.  Otherwise, indices are chosen non-uniformly with interval of
approximately g in order to end up with approximately T/g total indices</div></blockquote>
<p class="last">verbose (logical) - if True, some output is printed</p>
</dd>
<dt>RETURNS  </dt>
<dd>indices (list of int) - the indices of an uncorrelated subsample of the data</dd>
<dt>NOTES</dt>
<dd>The statistical inefficiency is computed with the function computeStatisticalInefficiency().</dd>
<dt>TODO</dt>
<dd>Instead of using regular stride, use irregular stride so more data can be fit in when g is non-integral.</dd>
</dl>
<p>EXAMPLES</p>
<p>Subsample a correlated timeseries to extract an effectively uncorrelated dataset.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_t</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">correlated_timeseries_example</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span> <span class="c"># generate a test correlated timeseries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">subsampleCorrelatedData</span><span class="p">(</span><span class="n">A_t</span><span class="p">)</span> <span class="c"># compute indices of uncorrelated timeseries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_n</span> <span class="o">=</span> <span class="n">A_t</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="c"># extract uncorrelated samples</span>
</pre></div>
</div>
<p>Extract uncorrelated samples from multiple timeseries data from the same process.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Generate multiple correlated timeseries data of different lengths.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_k</span><span class="p">)</span> <span class="c"># number of timeseries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="c"># exponential relaxation time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_kt</span> <span class="o">=</span> <span class="p">[</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">correlated_timeseries_example</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">T_k</span> <span class="p">]</span> <span class="c"># A_kt[k] is correlated timeseries k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Estimate statistical inefficiency from all timeseries data.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">statisticalInefficiencyMultiple</span><span class="p">(</span><span class="n">A_kt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Count number of uncorrelated samples in each timeseries.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N_k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsampleCorrelatedData</span><span class="p">(</span><span class="n">A_t</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">))</span> <span class="k">for</span> <span class="n">A_t</span> <span class="ow">in</span> <span class="n">A_kt</span> <span class="p">])</span> <span class="c"># N_k[k] is the number of uncorrelated samples in timeseries k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">N_k</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c"># total number of uncorrelated samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Subsample all trajectories to produce uncorrelated samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_kn</span> <span class="o">=</span> <span class="p">[</span> <span class="n">A_t</span><span class="p">[</span><span class="n">subsampleCorrelatedData</span><span class="p">(</span><span class="n">A_t</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">)]</span> <span class="k">for</span> <span class="n">A_t</span> <span class="ow">in</span> <span class="n">A_kt</span> <span class="p">]</span> <span class="c"># A_kn[k] is uncorrelated subset of trajectory A_kt[t]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Concatenate data into one timeseries.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c"># A_n[n] is nth sample in concatenated set of uncorrelated samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N_k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A_kn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">K</span><span class="p">):</span> <span class="n">A_n</span><span class="p">[</span><span class="n">N_k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span><span class="n">N_k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span> <span class="o">=</span> <span class="n">A_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="testsystems.html" class="btn btn-neutral float-right" title="The testsystems Module : pymbar.testsystems"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mbar.html" class="btn btn-neutral" title="The mbar module : pymbar.mbar"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, John D. Chodera, Michael Shirts, Kyle A. Beauchamp.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>