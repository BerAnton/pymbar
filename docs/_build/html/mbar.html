

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The mbar module : pymbar.mbar &mdash; pymbar 2.1.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="pymbar 2.1.0 documentation" href="index.html"/>
        <link rel="next" title="The timeseries module : pymbar.timeseries" href="timeseries.html"/>
        <link rel="prev" title="Getting started" href="getting_started.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> pymbar</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#installing-pymbar">Installing <tt class="docutils literal"><span class="pre">pymbar</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#running-the-tests">Running the tests</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">The mbar module : <tt class="docutils literal"><span class="pre">pymbar.mbar</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="timeseries.html">The timeseries module : <tt class="docutils literal"><span class="pre">pymbar.timeseries</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="testsystems.html">The testsystems Module : <tt class="docutils literal"><span class="pre">pymbar.testsystems</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utilities : <tt class="docutils literal"><span class="pre">pymbar.utils</span></tt></a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">pymbar</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>The mbar module : <tt class="docutils literal"><span class="pre">pymbar.mbar</span></tt></li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/mbar.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="the-mbar-module-pymbar-mbar">
<h1>The mbar module : <a class="reference internal" href="#module-pymbar.mbar" title="pymbar.mbar"><tt class="xref py py-class docutils literal"><span class="pre">pymbar.mbar</span></tt></a><a class="headerlink" href="#the-mbar-module-pymbar-mbar" title="Permalink to this headline">¶</a></h1>
<p>The mbar module contains the MBAR class, the key object in pymbar.</p>
<span class="target" id="module-pymbar.mbar"></span><p>Multistate Bennett acceptance ratio method (MBAR) for the analysis of multiple equilibrium samples.</p>
<p>A module implementing the multistate Bennett acceptance ratio (MBAR) method for the analysis
of equilibrium samples from multiple arbitrary thermodynamic states in computing equilibrium
expectations, free energy differences, potentials of mean force, and entropy and enthalpy contributions.</p>
<dl class="class">
<dt id="pymbar.mbar.MBAR">
<em class="property">class </em><tt class="descclassname">pymbar.mbar.</tt><tt class="descname">MBAR</tt><span class="sig-paren">(</span><em>u_kln</em>, <em>N_k</em>, <em>maximum_iterations=10000</em>, <em>relative_tolerance=1e-07</em>, <em>verbose=False</em>, <em>initial_f_k=None</em>, <em>method='adaptive'</em>, <em>use_optimized=None</em>, <em>newton_first_gamma=0.1</em>, <em>newton_self_consistent=2</em>, <em>maxrange=100000.0</em>, <em>initialize='zeros'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Multistate Bennett acceptance ratio method (MBAR) for the analysis of multiple equilibrium samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>u_kln</strong> : np.ndarray, float, shape=(K, L, N_max)</p>
<blockquote>
<div><p>u_kln[k,l,n] is the reduced potential energy of uncorrelated
configuration n sampled from state k, evaluated at state l.  K &gt;= L</p>
</div></blockquote>
<p><strong>N_k</strong> :  np.ndarray, int, shape=(K)</p>
<blockquote>
<div><p>N_k[k] is the number of uncorrelated snapshots sampled from state k
This can be zero if the expectation or free energy of this
state is desired but no samples were drawn from this state.</p>
</div></blockquote>
<p><strong>maximum_iterations</strong> : int, optional</p>
<blockquote>
<div><p>Set to limit the maximum number of iterations performed (default 1000)</p>
</div></blockquote>
<p><strong>relative_tolerance</strong> : float, optional</p>
<blockquote>
<div><p>Set to determine the relative tolerance convergence criteria (default 1.0e-6)</p>
</div></blockquote>
<p><strong>verbosity</strong> : bool, optional</p>
<blockquote>
<div><p>Set to True if verbose debug output is desired (default False)</p>
</div></blockquote>
<p><strong>initial_f_k</strong> : np.ndarray, float, shape=(K), optional</p>
<blockquote>
<div><p>Set to the initial dimensionless free energies to use as a 
guess (default None, which sets all f_k = 0)</p>
</div></blockquote>
<p><strong>method</strong> : string, optional</p>
<blockquote>
<div><p>Method for determination of dimensionless free energies: 
Must be one of &#8216;self-consistent-iteration&#8217;,&#8217;Newton-Raphson&#8217;, 
or &#8216;adaptive&#8217; (default: &#8216;adaptive&#8217;).
Newton-Raphson is deprecated and defaults to adaptive</p>
</div></blockquote>
<p><strong>use_optimized</strong> : bool, optional</p>
<blockquote>
<div><p>If False, will explicitly disable use of C++ extensions.
If None or True, extensions will be autodetected (default: None)</p>
</div></blockquote>
<p><strong>initialize</strong> : string, optional</p>
<blockquote>
<div><p>If equal to &#8216;BAR&#8217;, use BAR between the pairwise state to 
initialize the free energies.  Eventually, should specify a path; 
for now, it just does it zipping up the states. 
(default: &#8216;zeros&#8217;, unless specific values are passed in.)</p>
</div></blockquote>
<p><strong>newton_first_gamma</strong> : float, optional</p>
<blockquote>
<div><p>Initial gamma for newton-raphson (default = 0.1)</p>
</div></blockquote>
<p><strong>newton_self_consistent</strong> : int, optional</p>
<blockquote class="last">
<div><p>Mininum number of self-consistent iterations before 
Newton-Raphson iteration (default = 2)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note that this method assumes the data are uncorrelated.
Correlated data must be subsampled to extract uncorrelated (effectively independent) samples (see example below).</p>
<p>Upon initialization, the dimensionless free energies for all states are computed.
This may take anywhere from seconds to minutes, depending upon the quantity of data.
After initialization, the computed free energies may be obtained by a call to &#8216;getFreeEnergies()&#8217;, or
free energies or expectation at any state of interest can be computed by calls to &#8216;computeFreeEnergy()&#8217; or
&#8216;computeExpectations()&#8217;.</p>
<p>The reduced potential energy u_kln[k,l,n] = u_l(x_{kn}), where the reduced potential energy u_l(x) is defined (as in the text) by:
u_l(x) = beta_l [ U_l(x) + p_l V(x) + mu_l&#8217; n(x) ]
where
beta_l = 1/(kB T_l) is the inverse temperature of condition l, where kB is Boltzmann&#8217;s constant
U_l(x) is the potential energy function for state l
p_l is the pressure at state l (if an isobaric ensemble is specified)
V(x) is the volume of configuration x
mu_l is the M-vector of chemical potentials for the various species, if a (semi)grand ensemble is specified, and &#8216; denotes transpose
n(x) is the M-vector of numbers of the various molecular species for configuration x, corresponding to the chemical potential components of mu_m.</p>
<p>The configurations x_kn must be uncorrelated.  This can be ensured by subsampling a correlated timeseries with a period larger than the statistical inefficiency,
which can be estimated from the potential energy timeseries {u_k(x_kn)}_{n=1}^{N_k} using the provided utility function &#8216;statisticalInefficiency()&#8217;.
See the help for this function for more information.</p>
<p class="rubric">References</p>
<p>[1] Shirts MR and Chodera JD. Statistically optimal analysis of samples from multiple equilibrium states.
J. Chem. Phys. 129:124105, 2008 <a class="reference external" href="http://dx.doi.org/10.1063/1.2978177">http://dx.doi.org/10.1063/1.2978177</a></p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsTestCase</span><span class="p">()</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>    
</pre></div>
</div>
<dl class="method">
<dt id="pymbar.mbar.MBAR.computeEntropyAndEnthalpy">
<tt class="descname">computeEntropyAndEnthalpy</tt><span class="sig-paren">(</span><em>uncertainty_method=None</em>, <em>verbose=False</em>, <em>warning_cutoff=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.computeEntropyAndEnthalpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose free energy differences into enthalpy and entropy differences.</p>
<p>Compute the decomposition of the free energy difference between
states 1 and N into reduced free energy differences, reduced potential
(enthalpy) differences, and reduced entropy (S/k) differences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>uncertainty_method</strong> : string , optional</p>
<blockquote>
<div><p>Choice of method used to compute asymptotic covariance method, or None to use default
See help for computeAsymptoticCovarianceMatrix() for more information on various methods. (default: None)</p>
</div></blockquote>
<p><strong>warning_cutoff</strong> : float, optional</p>
<blockquote>
<div><p>Warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Delta_f_ij</strong> : np.ndarray, float, shape=(K, K)</p>
<blockquote>
<div><p>Delta_f_ij[i,j] is the dimensionless free energy difference f_j - f_i</p>
</div></blockquote>
<p><strong>dDelta_f_ij</strong> : np.ndarray, float, shape=(K, K)</p>
<blockquote>
<div><p>uncertainty in Delta_f_ij</p>
</div></blockquote>
<p><strong>Delta_u_ij</strong> : np.ndarray, float, shape=(K, K)</p>
<blockquote>
<div><p>Delta_u_ij[i,j] is the reduced potential energy difference u_j - u_i</p>
</div></blockquote>
<p><strong>dDelta_u_ij</strong> : np.ndarray, float, shape=(K, K)</p>
<blockquote>
<div><p>uncertainty in Delta_f_ij</p>
</div></blockquote>
<p><strong>Delta_s_ij</strong> : np.ndarray, float, shape=(K, K)</p>
<blockquote>
<div><p>Delta_s_ij[i,j] is the reduced entropy difference S/k between states i and j (s_j - s_i)</p>
</div></blockquote>
<p><strong>dDelta_s_ij</strong> : np.ndarray, float, shape=(K, K)</p>
<blockquote class="last">
<div><p>uncertainty in Delta_s_ij</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method is EXPERIMENTAL and should be used at your own risk.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsTestCase</span><span class="p">()</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">Delta_f_ij</span><span class="p">,</span> <span class="n">dDelta_f_ij</span><span class="p">,</span> <span class="n">Delta_u_ij</span><span class="p">,</span> <span class="n">dDelta_u_ij</span><span class="p">,</span> <span class="n">Delta_s_ij</span><span class="p">,</span> <span class="n">dDelta_s_ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeEntropyAndEnthalpy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computeExpectations">
<tt class="descname">computeExpectations</tt><span class="sig-paren">(</span><em>A_kn</em>, <em>output='averages'</em>, <em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.computeExpectations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the expectation of an observable of phase space function.</p>
<p>Compute the expectation of an observable of phase space function 
A(x) at all K states, including states for which no samples 
were drawn. A may be a function of the state k.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : np.ndarray, float</p>
<blockquote>
<div><p>Two possibilities, depending on if the observable is a function of the state or not.
either: not dependent on the state
A_kn (KxN_max numpy float64 array) - A_kn[k,n] = A(x_kn)
or: dependent on state
A_kn (KxKxN_max numpy float64 array) - A_kn[k,l,n] = A(x_kn)
where the 2nd dimension is the observable as a function of the state</p>
</div></blockquote>
<p><strong>output</strong> : string, optional</p>
<blockquote>
<div><p>Either output averages, and uncertainties, or output a matrix of differences, with uncertainties.</p>
</div></blockquote>
<p><strong>compute_uncertainty</strong> : bool, optional</p>
<blockquote>
<div><p>If False, the uncertainties will not be computed (default: True)</p>
</div></blockquote>
<p><strong>uncertainty_method</strong> : string, optional</p>
<blockquote>
<div><p>Choice of method used to compute asymptotic covariance method, 
or None to use default See help for computeAsymptoticCovarianceMatrix()
for more information on various methods. (default: None)</p>
</div></blockquote>
<p><strong>warning_cutoff</strong> : float, optional</p>
<blockquote>
<div><p>Warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)</p>
</div></blockquote>
<p><strong>return_theta</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to return the theta matrix.  Can be useful for complicated differences.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A</strong> : np.ndarray, float</p>
<blockquote>
<div><p>if output is &#8216;averages&#8217;
A_i  (K numpy float64 array) -  A_i[k] is the estimate for the expectation of A(x) for state k.
if output is &#8216;differences&#8217;
A_ij (K numpy float64 array) -  A_ij[i,j] is the difference in the estimates for the expectation of A(x).</p>
</div></blockquote>
<p><strong>dA</strong> : np.ndarray, float</p>
<blockquote class="last">
<div><p>dA_i  (K numpy float64 array) - dA_i[k] is uncertainty estimate (one standard deviation) for A_k[k]
or
dA_ij (K numpy float64 array) - dA_ij[i,j] is uncertainty estimate (one standard deviation) for the difference in A beteen i and j</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The reported statistical uncertainty should, in the asymptotic limit,
reflect one standard deviation for the normal distribution of the estimate.
The true expectation should fall within the interval [-dA, +dA] centered on the estimate 68% of the time, and within
the interval [-2 dA, +2 dA] centered on the estimate 95% of the time.
This will break down in cases where the number of samples is not large enough to reach the asymptotic normal limit.
This &#8216;breakdown&#8217; can be exacerbated by the computation of observables like indicator functions for histograms that are sparsely populated.</p>
<p class="rubric">References</p>
<p>See Section IV of [1].</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsTestCase</span><span class="p">()</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_kn</span> <span class="o">=</span> <span class="n">x_kn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A_ij</span><span class="p">,</span> <span class="n">dA_ij</span><span class="p">)</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeExpectations</span><span class="p">(</span><span class="n">A_kn</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_kn</span> <span class="o">=</span> <span class="n">u_kln</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A_ij</span><span class="p">,</span> <span class="n">dA_ij</span><span class="p">)</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeExpectations</span><span class="p">(</span><span class="n">A_kn</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&#39;differences&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computeMultipleExpectations">
<tt class="descname">computeMultipleExpectations</tt><span class="sig-paren">(</span><em>A_ikn</em>, <em>u_kn</em>, <em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.computeMultipleExpectations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the expectations of multiple observables of phase space functions.</p>
<p>Compute the expectations of multiple observables of phase space functions.
[A_0(x),A_1(x),...,A_n(x)] at single specified state, 
along with the covariances of their estimates.  The state is specified by
the choice of u_kn, which is the energy of the kxn samples evaluated at the chosen state.  Note that
these variables A should NOT be functions of the state!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A_ikn</strong> : np.ndarray, float, shape=(I, k, N_max)</p>
<blockquote>
<div><p>A_ikn[i,k,n] = A_i(x_kn), the value of phase observable i for configuration n at state k</p>
</div></blockquote>
<p><strong>u_kn</strong> : np.ndarray, float, shape=(K, N_max)</p>
<blockquote>
<div><p>u_kn[k,n] is the reduced potential of configuration n gathered from state k, at the state of interest</p>
</div></blockquote>
<p><strong>uncertainty_method</strong> : string, optional</p>
<blockquote>
<div><p>Choice of method used to compute asymptotic covariance method, or None to use default
See help for computeAsymptoticCovarianceMatrix() for more information on various methods. (default: None)</p>
</div></blockquote>
<p><strong>warning_cutoff</strong> : float, optional</p>
<blockquote>
<div><p>Warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)</p>
</div></blockquote>
<p><strong>return_theta</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to return the theta matrix.  Can be useful for complicated differences.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A_i</strong> : np.ndarray, float, shape=(I)</p>
<blockquote>
<div><p>A_i[i] is the estimate for the expectation of A_i(x) at the state specified by u_kn</p>
</div></blockquote>
<p><strong>d2A_ij</strong> : np.ndarray, float, shape=(I, I)</p>
<blockquote class="last">
<div><p>d2A_ij[i,j] is the COVARIANCE in the estimates of A_i[i] and A_i[j],
not the square root of the covariance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Not fully tested!</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsTestCase</span><span class="p">()</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_ikn</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_kn</span><span class="p">,</span><span class="n">x_kn</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">x_kn</span><span class="o">**</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_kn</span> <span class="o">=</span> <span class="n">u_kln</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">A_i</span><span class="p">,</span> <span class="n">d2A_ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeMultipleExpectations</span><span class="p">(</span><span class="n">A_ikn</span><span class="p">,</span> <span class="n">u_kn</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computeOverlap">
<tt class="descname">computeOverlap</tt><span class="sig-paren">(</span><em>output='scalar'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.computeOverlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute estimate of overlap matrix between the states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>output</strong> : string, optional</p>
<blockquote>
<div><p>One of &#8216;scalar&#8217;, &#8216;matrix&#8217;, &#8216;eigenvalues&#8217;, &#8216;all&#8217;, specifying</p>
</div></blockquote>
<p><strong>what measure of overlap to return</strong> :</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>O</strong> : np.ndarray, float, shape=(K, K)</p>
<blockquote class="last">
<div><p>estimated state overlap matrix: O[i,j] is an estimate
of the probability of observing a sample from state i in state j</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>W.T * W pprox int (p_i p_j /sum_k N_k p_k)^2 sum_k N_k p_k dq^N</dt>
<dd>= int (p_i p_j /sum_k N_k p_k) dq^N</dd>
</dl>
<p>Multiplying elementwise by N_i, the elements of row i give the probability
for a sample from state i being observed in state j.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsTestCase</span><span class="p">()</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O_ij</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computeOverlap</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computePMF">
<tt class="descname">computePMF</tt><span class="sig-paren">(</span><em>u_kn</em>, <em>bin_kn</em>, <em>nbins</em>, <em>uncertainties='from-lowest'</em>, <em>pmf_reference=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.computePMF" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the free energy of occupying a number of bins.</p>
<p>This implementation computes the expectation of an indicator-function observable for each bin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>u_kn</strong> : np.ndarray, float, shape=(K, N_max) ???</p>
<blockquote>
<div><p>u_kn[k,n] is the reduced potential energy of snapshot n of state k for which the PMF is to be computed.</p>
</div></blockquote>
<p><strong>bin_kn</strong> : np.ndarray, float, shape=(K, N_max) ???</p>
<blockquote>
<div><p>bin_kn[k,n] is the bin index of snapshot n of state k.  bin_kn can assume a value in range(0,nbins)</p>
</div></blockquote>
<p><strong>nbins</strong> : int</p>
<blockquote>
<div><p>The number of bins</p>
</div></blockquote>
<p><strong>uncertainties</strong> : string, optional</p>
<blockquote>
<div><p>Method for reporting uncertainties (default: &#8216;from-lowest&#8217;)
&#8216;from-lowest&#8217; - the uncertainties in the free energy difference with lowest point on PMF are reported
&#8216;from-reference&#8217; - same as from lowest, but from a user specified point
&#8216;from-normalization&#8217; - the normalization sum_i p_i = 1 is used to determine uncertainties spread out through the PMF
&#8216;all-differences&#8217; - the nbins x nbins matrix df_ij of uncertainties in free energy differences is returned instead of df_i</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_i</strong> : np.ndarray, float, shape=(K)</p>
<blockquote>
<div><p>f_i[i] is the dimensionless free energy of state i, relative to the state of lowest free energy</p>
</div></blockquote>
<p><strong>df_i</strong> : np.ndarray, float, shape=(K)</p>
<blockquote class="last">
<div><p>df_i[i] is the uncertainty in the difference of f_i with respect to the state of lowest free energy</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>All bins must have some samples in them from at least one of the states &#8211; this will not work if bin_kn.sum(0) == 0. Empty bins should be removed before calling computePMF().
This method works by computing the free energy of localizing the system to each bin for the given potential by aggregating the log weights for the given potential.
To estimate uncertainties, the NxK weight matrix W_nk is augmented to be Nx(K+nbins) in order to accomodate the normalized weights of states where
the potential is given by u_kn within each bin and infinite potential outside the bin.  The uncertainties with respect to the bin of lowest free energy
are then computed in the standard way.</p>
<p>WARNING
This method is EXPERIMENTAL and should be used at your own risk.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Generate some test data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsTestCase</span><span class="p">()</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Initialize MBAR on data.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select the potential we want to compute the PMF for (here, condition 0).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_kn</span> <span class="o">=</span> <span class="n">u_kln</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Sort into nbins equally-populated bins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nbins</span> <span class="o">=</span> <span class="mi">10</span> <span class="c"># number of equally-populated bins to use</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N_tot</span> <span class="o">=</span> <span class="n">N_k</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_n_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">x_kn</span><span class="p">[</span><span class="n">mbar</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span> <span class="c"># unroll to n-indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_n_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">::(</span><span class="n">N_tot</span><span class="o">/</span><span class="n">nbins</span><span class="p">)],</span> <span class="n">x_n_sorted</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bin_widths</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bin_kn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x_kn</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bin_kn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="n">bin_kn</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x_kn</span><span class="p">[</span><span class="n">k</span><span class="p">,:],</span> <span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Compute PMF for these unequally-sized bins.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">f_i</span><span class="p">,</span> <span class="n">df_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computePMF</span><span class="p">(</span><span class="n">u_kn</span><span class="p">,</span> <span class="n">bin_kn</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># If we want to correct for unequally-spaced bins to get a PMF on uniform measure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_i_corrected</span> <span class="o">=</span> <span class="n">f_i</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">bin_widths</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computePMF_states">
<tt class="descname">computePMF_states</tt><span class="sig-paren">(</span><em>u_kn</em>, <em>bin_kn</em>, <em>nbins</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.computePMF_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the free energy of occupying a number of bins.</p>
<p>This implementation defines each bin as a separate thermodynamic state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>u_kn</strong> : np.ndarray, float, shape=(K, N_max) ???</p>
<blockquote>
<div><p>u_kn[k,n] is the reduced potential energy of snapshot n of state k for which the PMF is to be computed.</p>
</div></blockquote>
<p><strong>bin_kn</strong> : np.ndarray, int, shape=(K, N_max) ???</p>
<blockquote>
<div><p>bin_kn[k,n] is the bin index of snapshot n of state k.  bin_kn can assume a value in range(0,nbins)</p>
</div></blockquote>
<p><strong>nbins</strong> : int</p>
<blockquote>
<div><p>The number of bins</p>
</div></blockquote>
<p><strong>fmax</strong> : float, optional</p>
<blockquote>
<div><p>The maximum value of the free energy, used for an empty bin (default: 1000)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_i</strong> : np.ndarray, float, shape=(K)</p>
<blockquote>
<div><p>f_i[i] is the dimensionless free energy of state i, relative to the state of lowest free energy</p>
</div></blockquote>
<p><strong>d2f_ij</strong> : np.ndarray, float, shape=(K)</p>
<blockquote class="last">
<div><p>d2f_ij[i,j] is the uncertainty in the difference of (f_i - f_j)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>All bins must have some samples in them from at least one of the states &#8211; this will not work if bin_kn.sum(0) == 0. Empty bins should be removed before calling computePMF().
This method works by computing the free energy of localizing the system to each bin for the given potential by aggregating the log weights for the given potential.
To estimate uncertainties, the NxK weight matrix W_nk is augmented to be Nx(K+nbins) in order to accomodate the normalized weights of states where
the potential is given by u_kn within each bin and infinite potential outside the bin.  The uncertainties with respect to the bin of lowest free energy
are then computed in the standard way.</p>
<p>WARNING!
This method is EXPERIMENTAL and should be used at your own risk.</p>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computePerturbedExpectation">
<tt class="descname">computePerturbedExpectation</tt><span class="sig-paren">(</span><em>u_kn</em>, <em>A_kn</em>, <em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.computePerturbedExpectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the expectation of an observable of phase space function A(x) for a single new state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>u_kn</strong> : np.ndarray, float, shape=(K, N_max)</p>
<blockquote>
<div><p>u_kn[k,n] = u(x_kn) - the energy of the new state at all N samples previously sampled.</p>
</div></blockquote>
<p><strong>A_kn</strong> : np.ndarray, float, shape=(K, N_max)</p>
<blockquote>
<div><p>A_kn[k,n] = A(x_kn) - the phase space function of the new state at all N samples previously sampled.  If this does NOT depend on state (e.g. position), it&#8217;s simply the value of the observation.  If it DOES depend on the current state, then the observables from the previous states need to be reevaluated at THIS state.</p>
</div></blockquote>
<p><strong>compute_uncertainty</strong> : bool, optional</p>
<blockquote>
<div><p>If False, the uncertainties will not be computed (default: True)</p>
</div></blockquote>
<p><strong>uncertainty_method</strong> : string, optional</p>
<blockquote>
<div><p>Choice of method used to compute asymptotic covariance method, or None to use default
See help for computeAsymptoticCovarianceMatrix() for more information on various methods. (default: None)</p>
</div></blockquote>
<p><strong>warning_cutoff</strong> : float, optional</p>
<blockquote>
<div><p>Warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)</p>
</div></blockquote>
<p><strong>return_theta</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to return the theta matrix.  Can be useful for complicated differences.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A</strong> : float</p>
<blockquote>
<div><p>A is the estimate for the expectation of A(x) for the specified state</p>
</div></blockquote>
<p><strong>dA</strong> : float</p>
<blockquote class="last">
<div><p>dA is uncertainty estimate for A</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See Section IV of [1].
# Compute estimators and uncertainty.
#A = sum(W_nk[:,K] * A_n[:]) # Eq. 15 of [1]
#dA = abs(A) * numpy.sqrt(Theta_ij[K,K] + Theta_ij[K+1,K+1] - 2.0 * Theta_ij[K,K+1]) # Eq. 16 of [1]</p>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.computePerturbedFreeEnergies">
<tt class="descname">computePerturbedFreeEnergies</tt><span class="sig-paren">(</span><em>u_kln</em>, <em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.computePerturbedFreeEnergies" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the free energies for a new set of states.</p>
<p>Here, we desire the free energy differences among a set of new states, as well as the uncertainty estimates in these differences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>u_kln</strong> : np.ndarray, float, shape=(K, L, Nmax)</p>
<blockquote>
<div><p>u_kln[k,l,n] is the reduced potential energy of uncorrelated
configuration n sampled from state k, evaluated at new state l.
L need not be the same as K.</p>
</div></blockquote>
<p><strong>compute_uncertainty</strong> : bool, optional</p>
<blockquote>
<div><p>If False, the uncertainties will not be computed (default: True)</p>
</div></blockquote>
<p><strong>uncertainty_method</strong> : string, optional</p>
<blockquote>
<div><p>Choice of method used to compute asymptotic covariance method, or None to use default
See help for computeAsymptoticCovarianceMatrix() for more information on various methods. (default: None)</p>
</div></blockquote>
<p><strong>warning_cutoff</strong> : float, optional</p>
<blockquote>
<div><p>Warn if squared-uncertainty is negative and larger in magnitude than this number (default: 1.0e-10)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Deltaf_ij</strong> : np.ndarray, float, shape=(L, L)</p>
<blockquote>
<div><p>Deltaf_ij[i,j] = f_j - f_i, the dimensionless free energy difference between new states i and j</p>
</div></blockquote>
<p><strong>dDeltaf_ij</strong> : np.ndarray, float, shape=(L, L)</p>
<blockquote class="last">
<div><p>dDeltaf_ij[i,j] is the estimated statistical uncertainty in Deltaf_ij[i,j]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsTestCase</span><span class="p">()</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">Deltaf_ij</span><span class="p">,</span> <span class="n">dDeltaf_ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">computePerturbedFreeEnergies</span><span class="p">(</span><span class="n">u_kln</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.getFreeEnergyDifferences">
<tt class="descname">getFreeEnergyDifferences</tt><span class="sig-paren">(</span><em>compute_uncertainty=True</em>, <em>uncertainty_method=None</em>, <em>warning_cutoff=1e-10</em>, <em>return_theta=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.getFreeEnergyDifferences" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dimensionless free energy differences and uncertainties among all thermodynamic states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>compute_uncertainty</strong> : bool, optional</p>
<blockquote>
<div><p>If False, the uncertainties will not be computed (default: True)</p>
</div></blockquote>
<p><strong>uncertainty_method</strong> : string, optional</p>
<blockquote>
<div><p>Choice of method used to compute asymptotic covariance method,
or None to use default.  See help for computeAsymptoticCovarianceMatrix()
for more information on various methods. (default: svd)</p>
</div></blockquote>
<p><strong>warning_cutoff</strong> : float, optional</p>
<blockquote>
<div><p>Warn if squared-uncertainty is negative and larger in magnitude
than this number (default: 1.0e-10)</p>
</div></blockquote>
<p><strong>return_theta</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to return the theta matrix.  Can be useful for complicated differences.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Deltaf_ij :L np.ndarray, float, shape=(K, K)</strong> :</p>
<blockquote>
<div><p>Deltaf_ij[i,j] is the estimated free energy difference</p>
</div></blockquote>
<p><strong>dDeltaf_ij :L np.ndarray, float, shape=(K, K)</strong> :</p>
<blockquote class="last">
<div><p>dDeltaf_ij[i,j] is the estimated statistical uncertainty 
(one standard deviation) in Deltaf_ij[i,j]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Computation of the covariance matrix may take some time for large K.</p>
<p>The reported statistical uncertainty should, in the asymptotic limit, reflect one standard deviation for the normal distribution of the estimate.
The true free energy difference should fall within the interval [-df, +df] centered on the estimate 68% of the time, and within
the interval [-2 df, +2 df] centered on the estimate 95% of the time.
This will break down in cases where the number of samples is not large enough to reach the asymptotic normal limit.</p>
<p>See Section III of Reference [1].</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">testsystems</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x_kn</span><span class="p">,</span> <span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">testsystems</span><span class="o">.</span><span class="n">HarmonicOscillatorsTestCase</span><span class="p">()</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mbar</span> <span class="o">=</span> <span class="n">MBAR</span><span class="p">(</span><span class="n">u_kln</span><span class="p">,</span> <span class="n">N_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">Deltaf_ij</span><span class="p">,</span> <span class="n">dDeltaf_ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">mbar</span><span class="o">.</span><span class="n">getFreeEnergyDifferences</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pymbar.mbar.MBAR.getWeights">
<tt class="descname">getWeights</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymbar.mbar.MBAR.getWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the weight matrix W_nk from the MBAR algorithm.</p>
<p>Necessary because they are stored internally as log weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>weights</strong> : np.ndarray, float, shape=(N, K)</p>
<blockquote class="last">
<div><p>NxK matrix of weights in the MBAR covariance and averaging formulas</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="timeseries.html" class="btn btn-neutral float-right" title="The timeseries module : pymbar.timeseries"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="getting_started.html" class="btn btn-neutral" title="Getting started"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, John D. Chodera, Michael Shirts, Kyle A. Beauchamp.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>